// @flow strict

/**
 * This file is AUTOMATICALLY GENERATED.
 * DO NOT edit this file manually.
 *
 * Instead, update the `*.grammar` file, and re-run `generate-ast`
 */

import invariant from 'invariant';

import type { Encoding } from './encodings';
import type { Precision } from './types';

function isBytes(node: Node): boolean %checks {
  return (
    node.baseType === 'blob' ||
    node.baseType === 'binary' ||
    node.baseType === 'varbinary' ||
    node.baseType === 'tinyblob' ||
    node.baseType === 'mediumblob' ||
    node.baseType === 'longblob'
  );
}

function isDataType(node: Node): boolean %checks {
  return (
    node.baseType === 'enum' ||
    node.baseType === 'json' ||
    isNumeric(node) ||
    isTemporal(node) ||
    isTextual(node) ||
    isBytes(node)
  );
}

function isInteger(node: Node): boolean %checks {
  return (
    node.baseType === 'tinyint' ||
    node.baseType === 'mediumint' ||
    node.baseType === 'smallint' ||
    node.baseType === 'int' ||
    node.baseType === 'bigint'
  );
}

function isNumeric(node: Node): boolean %checks {
  return isInteger(node) || isReal(node);
}

function isReal(node: Node): boolean %checks {
  return node.baseType === 'decimal' || node.baseType === 'float' || node.baseType === 'double';
}

function isTemporal(node: Node): boolean %checks {
  return (
    node.baseType === 'datetime' ||
    node.baseType === 'timestamp' ||
    node.baseType === 'date' ||
    node.baseType === 'year' ||
    node.baseType === 'time'
  );
}

function isTextual(node: Node): boolean %checks {
  return (
    node.baseType === 'char' ||
    node.baseType === 'varchar' ||
    node.baseType === 'text' ||
    node.baseType === 'mediumtext' ||
    node.baseType === 'longtext'
  );
}

function isTextualOrEnum(node: Node): boolean %checks {
  return node.baseType === 'enum' || isTextual(node);
}

export type Bytes = Blob | Binary | VarBinary | TinyBlob | MediumBlob | LongBlob;

export type DataType = Numeric | Temporal | Textual | Enum | Bytes | Json;

export type Integer = TinyInt | MediumInt | SmallInt | Int | BigInt;

export type Numeric = Integer | Real;

export type Real = Decimal | Float | Double;

export type Temporal = DateTime | Timestamp | Date | Year | Time;

export type Textual = Char | VarChar | Text | MediumText | LongText;

export type TextualOrEnum = Textual | Enum;

export type Node =
  | BigInt
  | Binary
  | Blob
  | Char
  | Date
  | DateTime
  | Decimal
  | Double
  | Enum
  | Float
  | Int
  | Json
  | LongBlob
  | LongText
  | MediumBlob
  | MediumInt
  | MediumText
  | SmallInt
  | Text
  | Time
  | Timestamp
  | TinyBlob
  | TinyInt
  | VarBinary
  | VarChar
  | Year;

function isNode(node: Node): boolean %checks {
  return (
    node.baseType === 'bigint' ||
    node.baseType === 'binary' ||
    node.baseType === 'blob' ||
    node.baseType === 'char' ||
    node.baseType === 'date' ||
    node.baseType === 'datetime' ||
    node.baseType === 'decimal' ||
    node.baseType === 'double' ||
    node.baseType === 'enum' ||
    node.baseType === 'float' ||
    node.baseType === 'int' ||
    node.baseType === 'json' ||
    node.baseType === 'longblob' ||
    node.baseType === 'longtext' ||
    node.baseType === 'mediumblob' ||
    node.baseType === 'mediumint' ||
    node.baseType === 'mediumtext' ||
    node.baseType === 'smallint' ||
    node.baseType === 'text' ||
    node.baseType === 'time' ||
    node.baseType === 'timestamp' ||
    node.baseType === 'tinyblob' ||
    node.baseType === 'tinyint' ||
    node.baseType === 'varbinary' ||
    node.baseType === 'varchar' ||
    node.baseType === 'year'
  );
}

export type BigInt = {|
  baseType: 'bigint',
  length: number,
  unsigned: boolean,
|};

export type Binary = {|
  baseType: 'binary',
  length: number,
|};

export type Blob = {|
  baseType: 'blob',
  length: number,
|};

export type Char = {|
  baseType: 'char',
  length: number,
  encoding: Encoding | null,
|};

export type Date = {|
  baseType: 'date',
|};

export type DateTime = {|
  baseType: 'datetime',
  fsp: number | null,
|};

export type Decimal = {|
  baseType: 'decimal',
  precision: Precision | null,
  unsigned: boolean,
|};

export type Double = {|
  baseType: 'double',
  precision: Precision | null,
  unsigned: boolean,
|};

export type Enum = {|
  baseType: 'enum',
  values: Array<string>,
  encoding: Encoding | null,
|};

export type Float = {|
  baseType: 'float',
  precision: Precision | null,
  unsigned: boolean,
|};

export type Int = {|
  baseType: 'int',
  length: number,
  unsigned: boolean,
|};

export type Json = {|
  baseType: 'json',
|};

export type LongBlob = {|
  baseType: 'longblob',
|};

export type LongText = {|
  baseType: 'longtext',
  encoding: Encoding | null,
|};

export type MediumBlob = {|
  baseType: 'mediumblob',
|};

export type MediumInt = {|
  baseType: 'mediumint',
  length: number,
  unsigned: boolean,
|};

export type MediumText = {|
  baseType: 'mediumtext',
  encoding: Encoding | null,
|};

export type SmallInt = {|
  baseType: 'smallint',
  length: number,
  unsigned: boolean,
|};

export type Text = {|
  baseType: 'text',
  encoding: Encoding | null,
|};

export type Time = {|
  baseType: 'time',
|};

export type Timestamp = {|
  baseType: 'timestamp',
  fsp: number | null,
|};

export type TinyBlob = {|
  baseType: 'tinyblob',
|};

export type TinyInt = {|
  baseType: 'tinyint',
  length: number,
  unsigned: boolean,
|};

export type VarBinary = {|
  baseType: 'varbinary',
  length: number,
|};

export type VarChar = {|
  baseType: 'varchar',
  length: number,
  encoding: Encoding | null,
|};

export type Year = {|
  baseType: 'year',
|};

export default {
  BigInt(length: number, unsigned: boolean): BigInt {
    invariant(
      typeof length === 'number',
      `Invalid value for "length" arg in "BigInt" call.\nExpected: number\nGot:      ${JSON.stringify(length)}`,
    );

    invariant(
      typeof unsigned === 'boolean',
      `Invalid value for "unsigned" arg in "BigInt" call.\nExpected: boolean\nGot:      ${JSON.stringify(unsigned)}`,
    );

    return {
      baseType: 'bigint',
      length,
      unsigned,
    };
  },

  Binary(length: number): Binary {
    invariant(
      typeof length === 'number',
      `Invalid value for "length" arg in "Binary" call.\nExpected: number\nGot:      ${JSON.stringify(length)}`,
    );

    return {
      baseType: 'binary',
      length,
    };
  },

  Blob(length: number): Blob {
    invariant(
      typeof length === 'number',
      `Invalid value for "length" arg in "Blob" call.\nExpected: number\nGot:      ${JSON.stringify(length)}`,
    );

    return {
      baseType: 'blob',
      length,
    };
  },

  Char(length: number, encoding: Encoding | null = null): Char {
    invariant(
      typeof length === 'number',
      `Invalid value for "length" arg in "Char" call.\nExpected: number\nGot:      ${JSON.stringify(length)}`,
    );

    return {
      baseType: 'char',
      length,
      encoding,
    };
  },

  Date(): Date {
    return {
      baseType: 'date',
    };
  },

  DateTime(fsp: number | null = null): DateTime {
    invariant(
      fsp === null || typeof fsp === 'number',
      `Invalid value for "fsp" arg in "DateTime" call.\nExpected: number?\nGot:      ${JSON.stringify(fsp)}`,
    );

    return {
      baseType: 'datetime',
      fsp,
    };
  },

  Decimal(precision: Precision | null, unsigned: boolean): Decimal {
    invariant(
      typeof unsigned === 'boolean',
      `Invalid value for "unsigned" arg in "Decimal" call.\nExpected: boolean\nGot:      ${JSON.stringify(unsigned)}`,
    );

    return {
      baseType: 'decimal',
      precision,
      unsigned,
    };
  },

  Double(precision: Precision | null, unsigned: boolean): Double {
    invariant(
      typeof unsigned === 'boolean',
      `Invalid value for "unsigned" arg in "Double" call.\nExpected: boolean\nGot:      ${JSON.stringify(unsigned)}`,
    );

    return {
      baseType: 'double',
      precision,
      unsigned,
    };
  },

  Enum(values: Array<string>, encoding: Encoding | null = null): Enum {
    invariant(
      Array.isArray(values) && values.length > 0 && values.every((item) => typeof item === 'string'),
      `Invalid value for "values" arg in "Enum" call.\nExpected: string+\nGot:      ${JSON.stringify(values)}`,
    );

    return {
      baseType: 'enum',
      values,
      encoding,
    };
  },

  Float(precision: Precision | null, unsigned: boolean): Float {
    invariant(
      typeof unsigned === 'boolean',
      `Invalid value for "unsigned" arg in "Float" call.\nExpected: boolean\nGot:      ${JSON.stringify(unsigned)}`,
    );

    return {
      baseType: 'float',
      precision,
      unsigned,
    };
  },

  Int(length: number, unsigned: boolean): Int {
    invariant(
      typeof length === 'number',
      `Invalid value for "length" arg in "Int" call.\nExpected: number\nGot:      ${JSON.stringify(length)}`,
    );

    invariant(
      typeof unsigned === 'boolean',
      `Invalid value for "unsigned" arg in "Int" call.\nExpected: boolean\nGot:      ${JSON.stringify(unsigned)}`,
    );

    return {
      baseType: 'int',
      length,
      unsigned,
    };
  },

  Json(): Json {
    return {
      baseType: 'json',
    };
  },

  LongBlob(): LongBlob {
    return {
      baseType: 'longblob',
    };
  },

  LongText(encoding: Encoding | null = null): LongText {
    return {
      baseType: 'longtext',
      encoding,
    };
  },

  MediumBlob(): MediumBlob {
    return {
      baseType: 'mediumblob',
    };
  },

  MediumInt(length: number, unsigned: boolean): MediumInt {
    invariant(
      typeof length === 'number',
      `Invalid value for "length" arg in "MediumInt" call.\nExpected: number\nGot:      ${JSON.stringify(length)}`,
    );

    invariant(
      typeof unsigned === 'boolean',
      `Invalid value for "unsigned" arg in "MediumInt" call.\nExpected: boolean\nGot:      ${JSON.stringify(unsigned)}`,
    );

    return {
      baseType: 'mediumint',
      length,
      unsigned,
    };
  },

  MediumText(encoding: Encoding | null = null): MediumText {
    return {
      baseType: 'mediumtext',
      encoding,
    };
  },

  SmallInt(length: number, unsigned: boolean): SmallInt {
    invariant(
      typeof length === 'number',
      `Invalid value for "length" arg in "SmallInt" call.\nExpected: number\nGot:      ${JSON.stringify(length)}`,
    );

    invariant(
      typeof unsigned === 'boolean',
      `Invalid value for "unsigned" arg in "SmallInt" call.\nExpected: boolean\nGot:      ${JSON.stringify(unsigned)}`,
    );

    return {
      baseType: 'smallint',
      length,
      unsigned,
    };
  },

  Text(encoding: Encoding | null = null): Text {
    return {
      baseType: 'text',
      encoding,
    };
  },

  Time(): Time {
    return {
      baseType: 'time',
    };
  },

  Timestamp(fsp: number | null = null): Timestamp {
    invariant(
      fsp === null || typeof fsp === 'number',
      `Invalid value for "fsp" arg in "Timestamp" call.\nExpected: number?\nGot:      ${JSON.stringify(fsp)}`,
    );

    return {
      baseType: 'timestamp',
      fsp,
    };
  },

  TinyBlob(): TinyBlob {
    return {
      baseType: 'tinyblob',
    };
  },

  TinyInt(length: number, unsigned: boolean): TinyInt {
    invariant(
      typeof length === 'number',
      `Invalid value for "length" arg in "TinyInt" call.\nExpected: number\nGot:      ${JSON.stringify(length)}`,
    );

    invariant(
      typeof unsigned === 'boolean',
      `Invalid value for "unsigned" arg in "TinyInt" call.\nExpected: boolean\nGot:      ${JSON.stringify(unsigned)}`,
    );

    return {
      baseType: 'tinyint',
      length,
      unsigned,
    };
  },

  VarBinary(length: number): VarBinary {
    invariant(
      typeof length === 'number',
      `Invalid value for "length" arg in "VarBinary" call.\nExpected: number\nGot:      ${JSON.stringify(length)}`,
    );

    return {
      baseType: 'varbinary',
      length,
    };
  },

  VarChar(length: number, encoding: Encoding | null = null): VarChar {
    invariant(
      typeof length === 'number',
      `Invalid value for "length" arg in "VarChar" call.\nExpected: number\nGot:      ${JSON.stringify(length)}`,
    );

    return {
      baseType: 'varchar',
      length,
      encoding,
    };
  },

  Year(): Year {
    return {
      baseType: 'year',
    };
  },

  // Node groups
  isNode,
  isBytes,
  isDataType,
  isInteger,
  isNumeric,
  isReal,
  isTemporal,
  isTextual,
  isTextualOrEnum,
};

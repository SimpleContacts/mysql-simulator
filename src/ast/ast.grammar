"""
import type { Encoding } from './encodings';
import type { Precision } from './types';

export type UnaryOp = "+" | "-" | "!" | "is null" | "is not null";

type BooleanOp = "AND" | "OR" | "XOR";
type CmpOp = "=" | "<=>" | "!=" | "<>" | ">=" | "<=" | "<" | ">" | "LIKE" | "REGEXP" | "RLIKE";
type ArithmOp = "+" | "-" | "*" | "/" | "%" | "DIV";
export type BinaryOp = BooleanOp | CmpOp | ArithmOp;

export type GeneratedColumnMode = "STORED" | "VIRTUAL";
"""

Literal:
  # TODO: Remove this hardcoded "type" in favor of "_kind"
  type   "literal"
  value  mixed

Identifier:
  # TODO: Remove this hardcoded "type" in favor of "_kind"
  type  "identifier"
  name  string

UnaryExpression:
  # TODO: Remove this hardcoded "type" in favor of "_kind"
  type  "unary"
  op    UnaryOp
  expr  @Expression

BinaryExpression:
  # TODO: Remove this hardcoded "type" in favor of "_kind"
  type   "binary"
  op     BinaryOp
  expr1  @Expression
  expr2  @Expression

CallExpression:
  # TODO: Remove this hardcoded "type" in favor of "_kind"
  type    "callExpression"
  callee  BuiltInFunction
  # The args are optional. For example, when null, this means a "call" like
  # `CURRENT_TIMESTAMP`. But when "empty" (e.g. []) this denotes a call like
  # `NOW()`.
  args    @Expression*?

BuiltInFunction:
  # TODO: Remove this hardcoded "type" in favor of "_kind"
  type  "builtinFunction"
  name  string

@Expression:
  | Literal
  | Identifier
  | UnaryExpression
  | BinaryExpression
  | CallExpression

GeneratedDefinition:
  type  "generated"
  expr  @Expression
  mode  GeneratedColumnMode

TinyInt:
  baseType  "tinyint"
  length    number
  unsigned  boolean

SmallInt:
  baseType  "smallint"
  length    number
  unsigned  boolean

MediumInt:
  baseType  "mediumint"
  length    number
  unsigned  boolean

Int:
  baseType  "int"
  length    number
  unsigned  boolean

BigInt:
  baseType  "bigint"
  length    number
  unsigned  boolean

Decimal:
  baseType   "decimal"
  precision  Precision?
  unsigned   boolean

Float:
  baseType   "float"
  precision  Precision?
  unsigned   boolean

Double:
  baseType   "double"
  precision  Precision?
  unsigned   boolean

DateTime:
  baseType  "datetime"
  fsp       number?

Timestamp:
  baseType  "timestamp"
  fsp       number?

Date:
  baseType  "date"

Year:
  baseType  "year"

Time:
  # TODO: This may officially take an fsp, but we're not parsing it?
  # fsp  number
  baseType  "time"

@Real:
  | Decimal
  | Float
  | Double

@Integer:
  | TinyInt
  | MediumInt
  | SmallInt
  | Int
  | BigInt

@Numeric:
  | @Integer
  | @Real

@Temporal:
  | DateTime
  | Timestamp
  | Date
  | Year
  | Time

Text:
  baseType  "text"
  encoding  Encoding?

MediumText:
  baseType  "mediumtext"
  encoding  Encoding?

LongText:
  baseType  "longtext"
  encoding  Encoding?

Char:
  baseType  "char"
  length    number
  encoding  Encoding?

VarChar:
  baseType  "varchar"
  length    number
  encoding  Encoding?

Enum:
  baseType  "enum"
  values    string+
  encoding  Encoding?

@Textual:
  | Char
  | VarChar
  | Text
  | MediumText
  | LongText

@TextualOrEnum:
  | @Textual
  | Enum

TinyBlob:
  baseType  "tinyblob"

MediumBlob:
  baseType  "mediumblob"

LongBlob:
  baseType  "longblob"

Blob:
  baseType  "blob"
  length    number

Binary:
  baseType  "binary"
  length    number

VarBinary:
  baseType  "varbinary"
  length    number

@Bytes:
  | Blob
  | Binary
  | VarBinary
  | TinyBlob
  | MediumBlob
  | LongBlob

Json:
  baseType  "json"

@DataType:
  | @Numeric
  | @Temporal
  | @Textual
  | Enum
  | @Bytes
  | Json

#
# CURRENT_TIMESTAMP is special in MySQL. It has a few appearences, like:
# - As a variable: CURRENT_TIMESTAMP
# - As a function call: CURRENT_TIMESTAMP()
# - As a function call with precision: CURRENT_TIMESTAMP(6)
# - As one of its synonyms: LOCALTIME, LOCALTIMESTAMP
# - As one of its synonyms: LOCALTIME(), LOCALTIMESTAMP(), NOW()
#
CurrentTimestamp:
  precision  number?

@DefaultValue:
  | Literal
  | CurrentTimestamp

# Artificially include a "@Start" group here now, to avoid ast-generator error
# of "unused nodes". It will automatically combine everything into a "Node"
# type already. I will need to figure out if that default behaviour is useful,
# or if we should explicitly define it.
@Start:
  | @Expression
  | GeneratedDefinition
